var documenterSearchIndex = {"docs":
[{"location":"#HarmonicSteadyState.j","page":"Home","title":"HarmonicSteadyState.j","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for computing the classical steady state of the effective stroboscopic dynamical systems. Given one has the autonomous equations of motion of the system in the rotating frame of the characteristic response frequencies, it collect steady states methods to find and describe the stationary responses of the system. It supports the following methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fixed point steady states with Homotopy Continuation\nFinding Limit-cycle with Homotopy Continuation\nStability analysis\nLinear response of the steady state in the (non-)rotating frame\nParameter sweeps\nPlotting utilities","category":"page"},{"location":"#Other-packages-in-the-Quest-Ecosystem-compatible-with-HarmonicSteadyState.jl","page":"Home","title":"Other packages in the Quest Ecosystem compatible with HarmonicSteadyState.jl","text":"","category":"section"},{"location":"#[HarmonicBalance.jl](https://github.com/QuantumEngineeredSystems/HarmonicBalance.jl)","page":"Home","title":"HarmonicBalance.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for applying the harmonic balance method to classical driven nonlinear dynamical systems. It computes the stroboscopic effective equations of motion of the system at the characteristic response frequencies of the system. Both Krylov-Bogoliubov averaging method to higher orders and the harmonic balance method are implemented.","category":"page"},{"location":"examples/forward_transmission/#Linear-response-and-transmission/reflection-coeffictients-for-magnon-three-wave-mixing","page":"Forward transmission","title":"Linear response and transmission/reflection coeffictients for magnon three-wave mixing","text":"","category":"section"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"using HarmonicSteadyState, QuantumCumulants, Plots","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"Consider a model of nonlinear magnon-magnon coupling, as described in this paper. The model describes  a three-wave mixing interaction between a strongly driven k=0 FMR mode and two parametricallly excited propagating modes with opposite momentum pm k and at half frequency. In this notebook, we will show how the mean-field approximation can be used to calculate steady states, and to calculate the S_21 transmission coefficient.","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"hm = FockSpace(:magnon)\nhc = FockSpace(:polariton)\nh = hm ⊗ hc  # Hilbertspace\n\n@qnumbers m::Destroy(h, 1) c::Destroy(h, 2) # Operators\n\n@rnumbers Δ Vk Ωd γm γk # Parameters\nparam = [Δ, Vk, Ωd, γm, γk]\n\nH_RWA_sym = (\n    Δ * m' * m + Δ / 2 * c' * c + Vk * m * c' * c' + Vk * m' * c * c + (Ωd * m + Ωd * m')\n)\nops = [m, m', c, c'] # Operators for meanfield evolution\n\neqs_RWA = meanfield(ops, H_RWA_sym, [m, c]; rates=[γm, γk], order=1)\neqs_completed_RWA = complete(eqs_RWA) # Meanfield equations using QuantumCumulants.jl","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"We can use this meanfield equations to construct a HarmonicEquation object in HarmonicSteadyState.jl. In the construction, additional information is computed, such as the Jacobian of the equations, which is used to determine the stability if the the steady states.","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"harmonic_eq = HarmonicEquation(eqs_completed_RWA, param)","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"Let's sweep the power of the drive Omega_d, with Delta=0, and solve for the steady state. The steady-state solutions show that the FMR mode saturates after a threshold power, followed by the coherent excitation of the parametrically induced counter-propagating modes.","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"drive_range = range(0, 1.8, 100)\nfixed = (Δ => 0, Vk => 0.0002, γm => 0.1, γk => 0.01)\nvaried = (Ωd => drive_range)\nresult = get_steady_states(harmonic_eq, TotalDegree(), varied, fixed)\n\nplot(plot(result; y=\"1/sqrt(2)*(mᵣ+ mᵢ)\"), plot(result; y=\"1/sqrt(2)*(cᵣ + cᵢ)\"))\n\n# Linear response and S21","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"To find the response of the driven system to a second, weak probe, we use the method described here. Here, we calculate the response in the same rotating frame as the Hamiltonian. The linear response is related to the scattering parameter S_21 by S_21(omega)=1-sqrtkappa_ext chi(omega) where kappa_ext is the coupling of the system to the measurement apparatus.","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"The result below shows the characteristic splitting of the magnon resonance above the power threshold, which matches the experiment.","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"Ω_range = range(-0.1, 0.1, 500)\nχ3 = get_susceptibility(result, 1, Ω_range, 3);\nχ1 = get_susceptibility(result, 1, Ω_range, 1);\nκ_ext = 0.05\nS21_3 = 1 .- χ3 * κ_ext / 2\nS21_log_3 = 20 .* log10.(abs.(S21_3)) # expressed in dB\nS21_1 = 1 .- χ1 * κ_ext / 2\nS21_log_1 = 20 .* log10.(abs.(S21_1)) # expressed in dB","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"Compare the two branches","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"stable = get_class(result, 3, \"physical\")\nheatmap(\n    Ω_range, drive_range, vcat(S21_log_1', S21_log_3'); c=:matter, cbar_title=\"S21 (dB)\"\n)\nylabel!(\"Ω_d\")\nxlabel!(\"Probe detuning\")","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"","category":"page"},{"location":"examples/forward_transmission/","page":"Forward transmission","title":"Forward transmission","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 2:3","category":"page"},{"location":"API/#Finding-steady-states","page":"API","title":"Finding steady states","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.get_steady_states","page":"API","title":"HarmonicSteadyState.get_steady_states","text":"get_steady_states(\n    prob::HomotopyContinuationProblem,\n    method::HomotopyContinuationMethod;\n    show_progress=true,\n    sorting=:nearest,\n    classify_default=true,\n    verbose=false\n    )\n\nSolves problem with the method over the ranges specified by swept_parameters, keeping fixed_parameters constant. swept_parameters accepts pairs mapping symbolic variables to arrays or ranges. fixed_parameters accepts pairs mapping symbolic variables to numbers.\n\nKeyword arguments\n\nshow_progress: Indicate whether a progress bar should be displayed.\nsorting: the method used by sort_solutions to get continuous solutions branches.   The current options are :hilbert (1D sorting along a Hilbert curve), :nearest   (nearest-neighbor sorting) and :none.\nclassify_default: If true, the solutions will be classified using the default   classification method.\n\nExample\n\nsolving a simple harmonic oscillator m ddotx + γ dotx + ω_0^2 x = F cos(ωt) to obtain the response as a function of ω\n\n# having obtained a HomotopyContinuationProblem object, let's find steady states\njulia> range = (ω => range(0.8, 1.2, 100) ) # 100 parameter sets to solve\njulia> fixed = ParameterList(m => 1, γ => 0.01, F => 0.5, ω_0 => 1)\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 100 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n\n    Classes: stable, physical, Hopf, binary_labels\n\n\nIt is also possible to perform 2-dimensional sweeps.\n\n# The swept parameters take precedence over fixed -> use the same fixed\njulia> range = (ω => range(0.8,1.2,100), F => range(0.1,1.0,10) )\n\n# The swept parameters take precedence over fixed -> the F in fixed is now ignored\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 1000 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n\n    Classes: stable, physical, Hopf, binary_labels\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.SteadyStateProblem","page":"API","title":"HarmonicSteadyState.SteadyStateProblem","text":"SteadyStateProblem\n\nAbstract type for steady state problems.\n\n\n\n\n\n","category":"type"},{"location":"API/#HarmonicSteadyState.SteadyStateMethod","page":"API","title":"HarmonicSteadyState.SteadyStateMethod","text":"SteadyStateMethod\n\nAbstract type for steady state methods.\n\n\n\n\n\n","category":"type"},{"location":"API/#HarmonicSteadyState.Result","page":"API","title":"HarmonicSteadyState.Result","text":"mutable struct Result{D, SolType<:Number, ParType<:Number, F<:FunctionWrappers.FunctionWrapper{Array{SolType<:Number, 2}, Tuple{Array{SolType<:Number, 1}}}}\n\nStores the steady states of a HarmonicEquation.\n\nFields\n\nsolutions::Array{Array{Vector{SolType}, 1}, D} where {D, SolType<:Number}: The variable values of steady-state solutions.\nswept_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Vector{ParType}} where ParType<:Number: Values of all parameters for all solutions.\nfixed_parameters::OrderedCollections.OrderedDict{Symbolics.Num, ParType} where ParType<:Number: The parameters fixed throughout the solutions.\nproblem::HarmonicSteadyState.HomotopyContinuationProblem{ParType, F} where {SolType<:Number, ParType<:Number, F<:FunctionWrappers.FunctionWrapper{Matrix{SolType}, Tuple{Vector{SolType}}}}: The HomotopyContinuationProblem used to generate this.\nclasses::Dict{String, Array{BitVector, D}} where D: Maps strings such as \"stable\", \"physical\" etc to arrays of values, classifying the solutions (see method classify_solutions!).\n\nbinary_labels::Array{Int64}: Create binary classification of the solutions, such that each solution point receives an identifier based on its permutation of stable branches (allows to distinguish between different phases, which may have the same number of stable solutions). It works by converting each bitstring [is_stable(solution_1), is_stable(solution_2), ...,] into unique labels.\n\njacobian::FunctionWrappers.FunctionWrapper{Matrix{SolType}, Tuple{Vector{SolType}}} where SolType<:Number: The Jacobian function with fixed_parameters already substituted. Accepts a vector specifying the solution. If problem.jacobian is a symbolic matrix, this holds a compiled function.\n\nseed::UInt32: Seed used for the solver\n\n\n\n\n\n","category":"type"},{"location":"API/#Homotopy-Continuation","page":"API","title":"Homotopy Continuation","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.HomotopyContinuationProblem","page":"API","title":"HarmonicSteadyState.HomotopyContinuationProblem","text":"mutable struct HomotopyContinuationProblem{ParType<:Number, Jac<:FunctionWrappers.FunctionWrapper{Matrix{ComplexF64}, Tuple{Vector{ComplexF64}}}} <: HarmonicSteadyState.SteadyStateProblem\n\nHolds a set of algebraic equations describing the steady state of a system.\n\nFields\n\nvariables::Vector{Symbolics.Num}: The harmonic variables to be solved for.\nparameters::Vector{Symbolics.Num}: All symbols which are not the harmonic variables.\nswept_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Vector{ParType}} where ParType<:Number: The swept parameters in the homotopy.\nfixed_parameters::OrderedCollections.OrderedDict{Symbolics.Num, ParType} where ParType<:Number: The fixed parameters in the homotopy.\nsystem::HomotopyContinuation.ModelKit.System: The input object for HomotopyContinuation.jl solver methods.\njacobian::FunctionWrappers.FunctionWrapper{Matrix{ComplexF64}, Tuple{Vector{ComplexF64}}}: The Jacobian matrix (possibly symbolic or compiled function). If Matrix{Nan} and implicit function is compiled when a Result is created.\n\neom::HarmonicEquation: The HarmonicEquation object used to generate this HomotopyContinuationProblem.\n\nConstructors\n\nHomotopyContinuationProblem(\n    eom::HarmonicEquation,\n    swept::AbstractDict,\n    fixed::AbstractDict;\n    compile_Jacobian::Bool=true,\n)\n\n\n\n\n\n","category":"type"},{"location":"API/#HarmonicSteadyState.HomotopyContinuationMethod","page":"API","title":"HarmonicSteadyState.HomotopyContinuationMethod","text":"HomotopyContinuationMethod\n\nAbstract type for the steady state methods using HomotopyContinuation.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#HarmonicSteadyState.WarmUp","page":"API","title":"HarmonicSteadyState.WarmUp","text":"WarmUp\n\nThe Warm Up method prepares a warmup system with the Total Degree method using the parameter at index perturbed by perturbation_size. The warmup system is used to perform a homotopy using all other systems in the parameter sweep. It is very efficient for systems with minimal bifurcation in the parameter sweep. The Warm Up method should in theory guarantee to find all solutions, however, if the start_parameters is not proper (to close to the real line) it could miss some solutions.\n\nSeeHomotopyContinuation.jl for more information.\n\nFields\n\nwarm_up_method::Union{Polyhedral{T}, TotalDegree{T}} where T: Method used for the warmup system.\nstart_parameters::Vector: Start parameters.\nthread::Bool: Boolean indicating if threading is enabled.\ncheck_zero::Bool: Check if zero is a root\ntracker_options::HomotopyContinuation.TrackerOptions: Options for the tracker.\nendgame_options::HomotopyContinuation.EndgameOptions: Options for the endgame.\ncompile::Union{Bool, Symbol}: Compilation options.\nseed::UInt32: Seed for random number generation.\n\n\n\n\n\n","category":"type"},{"location":"API/#HarmonicSteadyState.TotalDegree","page":"API","title":"HarmonicSteadyState.TotalDegree","text":"TotalDegree\n\nThe Total Degree homotopy method performs a homotopy H(x t) = γ t G(x) + (1-t) F(x) from the trivial polynomial system F(x) =xᵢ^dᵢ +aᵢ with the maximal degree dᵢ determined by the Bezout bound. The method guarantees to find all solutions, however, it comes with a high computational cost. See HomotopyContinuation.jl for more information.\n\nFields\n\ngamma::Complex: Complex multiplying factor of the start system G(x) for the homotopy\nthread::Bool: Boolean indicating if threading is enabled.\ntracker_options::HomotopyContinuation.TrackerOptions: Options for the tracker.\nendgame_options::HomotopyContinuation.EndgameOptions: Options for the endgame.\ncompile::Union{Bool, Symbol}: Compilation options.\nseed::UInt32: Seed for random number generation.\n\n\n\n\n\n","category":"type"},{"location":"API/#HarmonicSteadyState.Polyhedral","page":"API","title":"HarmonicSteadyState.Polyhedral","text":"Polyhedral\n\nThe Polyhedral homotopy method constructs a homotopy based on the polyhedral structure of the polynomial system. It is more efficient than the Total Degree method for sparse systems, meaning most of the coefficients are zero. It can be especially useful if you don't need to find the zero solutions (only_non_zero = true), resulting in a speed up. See HomotopyContinuation.jl for more information.\n\nFields\n\nonly_non_zero::Bool: Boolean indicating if only non-zero solutions are considered.\nthread::Bool: Boolean indicating if threading is enabled.\ntracker_options::HomotopyContinuation.TrackerOptions: Options for the tracker.\nendgame_options::HomotopyContinuation.EndgameOptions: Options for the endgame.\ncompile::Union{Bool, Symbol}: Compilation options.\nseed::UInt32: Seed for random number generation.\n\n\n\n\n\n","category":"type"},{"location":"API/#Analyze-solutions","page":"API","title":"Analyze solutions","text":"","category":"section"},{"location":"API/#Access-steady-states","page":"API","title":"Access steady states","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.get_solutions","page":"API","title":"HarmonicSteadyState.get_solutions","text":"get_solutions(\n    res::Result, x::String;\n    branches=1:branch_count(res), realify=false, class=[\"stable\"], not_class=[]\n    )\nget_solutions(res::Result; branches=1:branch_count(res), class=[\"stable\"], not_class=[])\n\nExtract solution vectors from a Result object based on specified filtering criteria given by the class keywords. The first method allows extracting a specific solution component by name x. The second method returns complete solution vectors.\n\nKeyword arguments\n\nbranches=1:branch_count(res): Range of branches to include in the output\nrealify=false: Whether to convert complex solutions to real form\nclass=[\"physical\", \"stable\"]: Array of classification labels to include\nnot_class=[]: Array of classification labels to exclude\n\nReturns\n\nFiltered solution vectors matching the specified criteria\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.get_single_solution","page":"API","title":"HarmonicSteadyState.get_single_solution","text":"get_single_solution(\n    res::HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}};\n    branch,\n    index\n)\n\n\nReturn an ordered dictionary specifying all variables and parameters of the solution in result on branch at the position index.\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.attractors","page":"API","title":"HarmonicSteadyState.attractors","text":"attractors(res::Result{D}; class=\"stable\", not_class=[]) where D\n\nExtract attractors from a Result object. Returns an array of dictionaries, where each dictionary maps branch identifier to the attractor. The attractors are filtered by their corresponding class.\n\nKeyword arguments\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass::String       :   only count solutions in this class (\"all\" --> plot everything)\nnot_class::String   :   do not count solutions in this class\n\nReturns\n\nArray{Dict,D}: Vector of dictionaries mapping branch indices to points satisfying   the stability criteria at each parameter value\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.transform_solutions","page":"API","title":"HarmonicSteadyState.transform_solutions","text":"transform_solutions(\n    res::HarmonicSteadyState.Result{D, S, ParType, F} where {ParType<:Number, F<:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}}},\n    func;\n    branches,\n    realify\n) -> Vector\n\n\nTakes a Result object and a string f representing a Symbolics.jl expression. Returns an array with the values of f evaluated for the respective solutions. Additional substitution rules can be specified in rules in the format (\"a\" => val) or (a => val)\n\n\n\n\n\n","category":"function"},{"location":"API/#Classify-steady-states","page":"API","title":"Classify steady states","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.classify_solutions!","page":"API","title":"HarmonicSteadyState.classify_solutions!","text":"classify_solutions!(\n    res::HarmonicSteadyState.Result,\n    func::Union{Function, String},\n    name::String;\n    physical\n) -> Any\n\n\nCreates a solution class in res using the function func (parsed into Symbolics.jl input). The new class is labeled with name and stored under res.classes[name]. By default, only physical (real) solutions are classified, and false is returned for the rest. To also classify complex solutions, set physical=false.\n\nExample\n\n# solve a previously-defined problem\nres = get_steady_states(problem, swept_parameters, fixed_parameters)\n\n# classify, store in result.classes[\"large_amplitude\"]\nclassify_solutions!(res, \"sqrt(u1^2 + v1^2) > 1.0\" , \"large_amplitude\")\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.get_class","page":"API","title":"HarmonicSteadyState.get_class","text":"get_class(\n    res::HarmonicSteadyState.Result,\n    branch::Int64,\n    class::String\n) -> Any\n\n\nReturns an array of booleans classifying branch in the solutions in res according to class.\n\n\n\n\n\nget_class(\n    soln::HarmonicSteadyState.Result,\n    class::String\n) -> Vector\n\n\nReturns an array of booleans classifying each branch in the solutions in res according to class.\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.filter_result!","page":"API","title":"HarmonicSteadyState.filter_result!","text":"filter_result!(\n    res::HarmonicSteadyState.Result,\n    class::String\n)\n\n\nRemoves all solution branches from res where NONE of the solution falls into class. Typically used to filter out unphysical solutions to prevent huge file sizes.\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.phase_diagram","page":"API","title":"HarmonicSteadyState.phase_diagram","text":"phase_diagram(res::Result{D}; class=\"physical\", not_class=[]) where {D}\n\nCalculate the phase diagram from a Result object by summing over the number of states at each swept parameters.\n\nKeyword arguments\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass::String       :   only count solutions in this class (\"all\" --> plot everything)\nnot_class::String   :   do not count solutions in this class\n\nReturns\n\nArray{Int64,D}: Sum of states after applying the specified class masks\n\n\n\n\n\n","category":"function"},{"location":"API/#Steady-state-plotting","page":"API","title":"Steady state plotting","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"To use these plotting functions, you need to have the Plots package installed in the same enverionment and loaded.","category":"page"},{"location":"API/#RecipesBase.plot-Tuple{HarmonicSteadyState.Result, Vararg{Any}}","page":"API","title":"RecipesBase.plot","text":"plot(\n    res::HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},\n    varargs...;\n    cut,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Result object.\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass       :   only plot solutions in this class(es) (\"all\" --> plot everything)\nnot_class   :   do not plot solutions in this class(es)\n\nOther kwargs are passed onto Plots.gr().\n\nSee also plot!\n\nThe x,y,z arguments are Strings compatible with Symbolics.jl, e.g., y=2*sqrt(u1^2+v1^2) plots the amplitude of the first quadratures multiplied by 2.\n\n1D plots\n\nplot(res::Result; x::String, y::String, class=\"default\", not_class=[], kwargs...)\nplot(res::Result, y::String; kwargs...) # take x automatically from Result\n\nDefault behaviour is to plot stable solutions as full lines, unstable as dashed.\n\nIf a sweep in two parameters were done, i.e., dimension(res)==2, a one dimensional cut can be plotted by using the keyword cut were it takes a Pair{Num, Float} type entry. For example, plot(res, y=\"sqrt(u1^2+v1^2), cut=(λ => 0.2)) plots a cut at λ = 0.2.\n\n2D plots\n\nplot(res::Result; z::String, branch::Int64, class=\"physical\", not_class=[], kwargs...)\n\nTo make the 2d plot less chaotic it is required to specify the specific branch to plot, labeled by a Int64.\n\nThe x and y axes are taken automatically from res\n\n\n\n\n\n","category":"method"},{"location":"API/#RecipesBase.plot!-Tuple{HarmonicSteadyState.Result, Vararg{Any}}","page":"API","title":"RecipesBase.plot!","text":"plot!(\n    res::HarmonicSteadyState.Result,\n    varargs...;\n    kwargs...\n) -> Plots.Plot\n\n\nSimilar to plot but adds a plot onto an existing plot.\n\n\n\n\n\n","category":"method"},{"location":"API/#HarmonicSteadyState.plot_phase_diagram","page":"API","title":"HarmonicSteadyState.plot_phase_diagram","text":"plot_phase_diagram(\n    res::HarmonicSteadyState.Result{D, SolType} where SolType<:Number;\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the number of solutions in a Result object as a function of the parameters. Works with 1D and 2D datasets.\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass::String       :   only count solutions in this class (\"all\" --> plot everything)\nnot_class::String   :   do not count solutions in this class\n\nOther kwargs are passed onto Plots.gr()\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.plot_spaghetti","page":"API","title":"HarmonicSteadyState.plot_spaghetti","text":"plot_spaghetti(\n    res::HarmonicSteadyState.Result{D, SolType} where SolType<:Number;\n    x,\n    y,\n    z,\n    class,\n    not_class,\n    add,\n    kwargs...\n)\n\n\nPlot a three dimension line plot of a Result object as a function of the parameters. Works with 1D and 2D datasets.\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass::String       :   only count solutions in this class (\"all\" --> plot everything)\nnot_class::String   :   do not count solutions in this class\n\nOther kwargs are passed onto Plots.gr()\n\n\n\n\n\n","category":"function"},{"location":"API/#Linear-response","page":"API","title":"Linear response","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.LinearResponse.eigenvalues-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any}} where {D, S, P}","page":"API","title":"HarmonicSteadyState.LinearResponse.eigenvalues","text":"eigenvalues(res::Result, branch; class=[\"physical\"])\n\nCalculate the eigenvalues of the Jacobian matrix of the harmonic equations of a branch for a one dimensional sweep in the Result struct.\n\nArguments\n\nres::Result: Result object containing solutions and jacobian information\nbranch: Index of the solution branch to analyze\nclass=[\"physical\"]: Filter for solution classes to include, defaults to physical solutions\n\nReturns\n\nVector of filtered eigenvalues along the solution branch\n\nNotes\n\nCurrently only supports 1-dimensional parameter sweeps (D=1)\nWill throw an error if branch contains NaN values\nEigenvalues are filtered based on the specified solution classes\n\n\n\n\n\n","category":"method"},{"location":"API/#HarmonicSteadyState.LinearResponse.eigenvectors-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any}} where {D, S, P}","page":"API","title":"HarmonicSteadyState.LinearResponse.eigenvectors","text":"eigenvectors(res::Result, branch; class=[\"physical\"])\n\nget_Jacobiannch to analyze\n\nclass=[\"physical\"]: Filter for solution classes to include, defaults to physical solutions\n\nReturns\n\nVector of filtered eigenvectors along the solution branch\n\nNotes\n\nCurrently only supports 1-dimensional parameter sweeps (D=1)\nWill throw an error if branch contains NaN values\nEigenvectors are filtered based on the specified solution classes\n\n\n\n\n\n","category":"method"},{"location":"API/#HarmonicSteadyState.LinearResponse.get_forward_transmission_response-Tuple{HarmonicSteadyState.Result, Int64, Any, Int64, Any}","page":"API","title":"HarmonicSteadyState.LinearResponse.get_forward_transmission_response","text":"get_forward_transmission_response(\n    result::HarmonicSteadyState.Result,\n    op_index::Int64,\n    Ω_range,\n    branch::Int64,\n    external_damping;\n    class\n) -> Any\n\n\nCompute the response matrix or susceptibility to a probe in the rotating frame. Observables like forward_transmission response spectrum, i.e, how much of an input signal applied at port 1 emerges at port 2, can be computed using the susceptibility. Colloquially known as S21 parameter in microwave engineering. The amplitude and phase of S21 tell you how much signal is transmitted and with what delay or phase shift:\n\nIf S21 ≈ 1 (or 0 dB), the system transmits all power from input to output.\nIf S21 ≈ 0 (or very negative dB), very little signal is transmitted.\n\nArguments\n\nresult::Result: Result object containing the system's solutions\nop_index::Int: Index of operator in mean field equations to evaluate response for\nΩ_range: Range of frequencies to evaluate\nbranch::Int: Branch number to analyze\nclass=\"stable\": Class of solutions to evaluate response for\n\nReturns\n\nχ: Complex response matrix where rows correspond to frequencies and columns to solutions\n\nExample\n\nΩ_range = range(-0.2, 0.2, 500)\nexternal_damping=0.05\n\nS21 = get_forward_transmission_response(\n        result, 1 #=variable=#, Ω_range, 3 #=branch=#; external_damping);\n\nS21_log = 20 .* log10.(abs.(S21)) # expressed in dB\n\n\n\n\n\n","category":"method"},{"location":"API/#HarmonicSteadyState.LinearResponse.get_jacobian_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Symbolics.Num, Any, Int64}} where {D, S, P}","page":"API","title":"HarmonicSteadyState.LinearResponse.get_jacobian_response","text":"get_jacobian_response(\n    res::HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},\n    nat_var::Symbolics.Num,\n    Ω_range,\n    branch::Int64;\n    show_progress\n) -> Matrix\n\n\nCalculate the Jacobian response spectrum for a given system. Computes the magnitude of the Jacobian response for stable solutions across specified frequency ranges.\n\nArguments\n\nres::Result: Result object containing the system's solutions\nnat_var::Num: Natural variable to evaluate in the response\nΩ_range: Range of frequencies to evaluate\nbranch::Int or followed_branches::Vector{Int}: Branch number(s) to analyze\nshow_progress=true: Whether to show a progress bar\n\nReturns\n\nArray{P,2}: Complex response matrix where rows correspond to frequencies and columns to solutions\n\n\n\n\n\n","category":"method"},{"location":"API/#HarmonicSteadyState.LinearResponse.get_rotframe_jacobian_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any, Int64}} where {D, S, P}","page":"API","title":"HarmonicSteadyState.LinearResponse.get_rotframe_jacobian_response","text":"get_rotframe_jacobian_response(\n    res::HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},\n    Ω_range,\n    branch::Int64;\n    show_progress,\n    damping_mod\n)\n\n\nCalculate the rotating frame Jacobian response for a given branch. Computes the rotating frame Jacobian response by evaluating eigenvalues of the numerical Jacobian and calculating the response magnitude for each frequency in the range.\n\nArguments\n\nres::Result: Result object containing the system's solutions\nΩ_range: Range of frequencies to evaluate\nbranch::Int: Branch number to analyze\nshow_progress=true: Whether to show a progress bar\ndamping_mod: Damping modification parameter\n\nReturns\n\nArray{P,2}: Response matrix in the rotating frame\n\n\n\n\n\n","category":"method"},{"location":"API/#HarmonicSteadyState.LinearResponse.get_susceptibility-Tuple{HarmonicSteadyState.Result, Int64, Any, Int64}","page":"API","title":"HarmonicSteadyState.LinearResponse.get_susceptibility","text":"get_susceptibility(\n    result::HarmonicSteadyState.Result,\n    op_index::Int64,\n    Ω_range,\n    branch::Int64;\n    class\n) -> Matrix{ComplexF64}\n\n\nCompute the response matrix or susceptibility to a probe in the rotating frame. Observables like forward_transmission response spectrum, i.e, how much of an input signal applied at port 1 emerges at port 2, can be computed using the susceptibility.\n\nArguments\n\nresult::Result: Result object containing the system's solutions\nop_index::Int: Index of operator in mean field equations to evaluate response for\nΩ_range: Range of frequencies to evaluate\nbranch::Int: Branch number to analyze\nclass=\"stable\": Class of solutions to evaluate response for\n\nReturns\n\nχ: Complex response matrix where rows correspond to frequencies and columns to solutions\n\nExample\n\nΩ_range = range(-0.2, 0.2, 500)\n\nχ = get_susceptibility(result, 1#=variable=#, Ω_range, 3 #=branch=#);\n\nκ_ext = 0.05\nS21 = 1 .- χ*κ_ext/2\nS21_log = 20 .* log10.(abs.(S21)) # expressed in dB\n\n\n\n\n\n","category":"method"},{"location":"API/#Linear-response-plotting","page":"API","title":"Linear response plotting","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.plot_eigenvalues","page":"API","title":"HarmonicSteadyState.plot_eigenvalues","text":"plot_eigenvalues(\n    res::HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},\n    branch::Int64;\n    class,\n    type,\n    projection,\n    cscheme,\n    kwargs...\n) -> Any\n\n\nVisualize the eigenvalues of the Jacobian in the rotating frame for branch identifier in the Result res.\n\nKeyword arguments\n\nclass: Array of solution classes to include (default: [\"physical\"])\ntype: Which part of eigenvalues to plot (:real or :imag, default: :imag)\nprojection: Function mapping eigenvectors to colors (default: v->1)\ncscheme: Color scheme for plotting (:default or custom scheme)\nkwargs...: Additional arguments passed to Plots.scatter\n\nReturns\n\nA scatter plot of eigenvalues colored by the projection of their eigenvectors.\n\nExample\n\n# Plot imaginary parts of eigenvalues\nplot_eigenvalues(result, branch=1)\n\n# Plot real parts with custom coloring based on the norm of eigenvectors of the first harmonic\nplot_eigenvalues(result, branch=1, type=:real, projection=v->sqrt(v[1]^2+v[2]^2))\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.plot_linear_response","page":"API","title":"HarmonicSteadyState.plot_linear_response","text":"plot_linear_response(\n    res::HarmonicSteadyState.Result{D, SolType} where SolType<:Number,\n    nat_var::Symbolics.Num,\n    branch::Int64;\n    Ω_range,\n    order,\n    logscale,\n    show_progress,\n    kwargs...\n)\n\n\nPlot the linear response to white noise of the variable nat_var for Result res on branch identifier.\n\nKeyword arguments\n\nΩ_range: Range of frequency of the noise probe\norder: Order of slow-time derivatives to keep (default: 1)\nlogscale: Whether to plot response in log scale (default: false)\nshow_progress: Show progress bar during computation (default: true)\nkwargs...: Additional arguments passed to Plots.heatmap\n\nReturns\n\nA Plots.jl heatmap showing the linear response magnitude across parameter and frequency space.\n\n\n\n\n\nplot_linear_response(\n    res::HarmonicSteadyState.Result,\n    nat_var::Symbolics.Num,\n    followed_branches::Vector{Int64};\n    Ω_range,\n    logscale,\n    show_progress,\n    switch_axis,\n    force,\n    kwargs...\n)\n\n\nPlot the linear response to white noise of the variable nat_var for Result res on the followed_branches identifiers with the size of Ω_range.\n\nKeyword arguments\n\nΩ_range: Range of frequency of the noise probe\norder: Order of slow-time derivatives to keep (default: 1)\nlogscale: Whether to plot response in log scale (default: false)\nshow_progress: Show progress bar during computation (default: true)\nkwargs...: Additional arguments passed to Plots.heatmap\n\nReturns\n\nA Plots.jl heatmap showing the linear response magnitude across parameter and frequency space.\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.plot_rotframe_jacobian_response","page":"API","title":"HarmonicSteadyState.plot_rotframe_jacobian_response","text":"plot_rotframe_jacobian_response(\n    res::HarmonicSteadyState.Result{D, S, P, F} where F<:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},\n    branch::Int64;\n    Ω_range,\n    logscale,\n    damping_mod,\n    show_progress,\n    kwargs...\n)\n\n\nPlot the linear response to white noise in the rotating frame defined the harmonic ansatz for Result res on branch identifier.\n\nKeyword arguments\n\nΩ_range: Range of frequencies to analyze\nlogscale: Whether to plot response in log scale (default: true)\ndamping_mod: Multiplier for the real part of Jacobian eigenvalues (default: 1.0)\nshow_progress: Show progress bar during computation (default: true)\nkwargs...: Additional arguments passed to Plots.heatmap\n\nReturns\n\nA Plots.jl heatmap showing the response magnitude in the rotating frame.\n\nNotes\n\nSetting damping_mod < 1 can help distinguish between peaks with similar frequencies\nSolutions not belonging to the physical class are ignored\n\n\n\n\n\n","category":"function"},{"location":"API/#Limit-cycle-methods","page":"API","title":"Limit-cycle methods","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.LimitCycles.get_limit_cycles","page":"API","title":"HarmonicSteadyState.LimitCycles.get_limit_cycles","text":"get_limit_cycles(\n    eom::HarmonicEquation, method::SteadyStateMethod, swept, fixed, ω_lc; kwargs...)\n\nVariant of get_steady_states for a limit cycle problem characterised by a Hopf frequency (usually called ω_lc)\n\nSolutions with ω_lc = 0 are labelled unphysical since this contradicts the assumption of distinct harmonic variables corresponding to distinct harmonics.\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.LimitCycles.add_pairs!","page":"API","title":"HarmonicSteadyState.LimitCycles.add_pairs!","text":"add_pairs!(eom::DifferentialEquation; ω_lc::Num, n=1)\n\nAdd a limit cycle harmonic ω_lc to the system Equivalent to adding n pairs of harmonics ω +- ω_lc for each existing ω.\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.LimitCycles.get_cycle_variables","page":"API","title":"HarmonicSteadyState.LimitCycles.get_cycle_variables","text":"get_cycle_variables(\n    eom::HarmonicEquation,\n    ω_lc::Symbolics.Num\n) -> Vector{QuestBase.HarmonicVariable}\n\n\nReturn the harmonic variables which participate in the limit cycle labelled by ω_lc.\n\n\n\n\n\n","category":"function"},{"location":"API/#OrdinaryDiffEq","page":"API","title":"OrdinaryDiffEq","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.AdiabaticSweep","page":"API","title":"HarmonicSteadyState.AdiabaticSweep","text":"Represents a sweep of one or more parameters of a HarmonicEquation. During a sweep, the selected parameters vary linearly over some timespan and are constant elsewhere.\n\nSweeps of different variables can be combined using +.\n\nFields\n\nfunctions::Dict{Symbolics.Num, Function}: Maps each swept parameter to a function.\n\nExamples\n\n# create a sweep of parameter a from 0 to 1 over time 0 -> 100\njulia> @variables a,b;\njulia> sweep = AdiabaticSweep(a => [0., 1.], (0, 100));\njulia> sweep[a](50)\n0.5\njulia> sweep[a](200)\n1.0\n\n# do the same, varying two parameters simultaneously\njulia> sweep = AdiabaticSweep([a => [0.,1.], b => [0., 1.]], (0,100))\n\nSuccessive sweeps can be combined,\n\nsweep1 = AdiabaticSweep(ω => [0.95, 1.0], (0, 2e4))\nsweep2 = AdiabaticSweep(λ => [0.05, 0.01], (2e4, 4e4))\nsweep = sweep1 + sweep2\n\nmultiple parameters can be swept simultaneously,\n\nsweep = AdiabaticSweep([ω => [0.95;1.0], λ => [5e-2;1e-2]], (0, 2e4))\n\nand custom sweep functions may be used.\n\nωfunc(t) = cos(t)\nsweep = AdiabaticSweep(ω => ωfunc)\n\n\n\n\n\n","category":"type"},{"location":"API/#HarmonicSteadyState.follow_branch","page":"API","title":"HarmonicSteadyState.follow_branch","text":"follow_branch(\n    starting_branch::Int64,\n    res::HarmonicSteadyState.Result;\n    y,\n    sweep,\n    tf,\n    ϵ\n) -> Tuple{Any, Any}\n\n\nReturn the indexes and values following stable branches along a 1D sweep. When a no stable solutions are found (e.g. in a bifurcation), the next stable solution is calculated by time evolving the previous solution (quench).\n\nKeyword arguments\n\ny:  Dependent variable expression (parsed into Symbolics.jl) to evaluate the followed solution branches on .\nsweep: Direction for the sweeping of solutions. A right (left) sweep proceeds from the first (last) solution, ordered as the sweeping parameter.\ntf: time to reach steady\nϵ: small random perturbation applied to quenched solution, in a bifurcation in order to favour convergence in cases where multiple solutions are identically accessible (e.g. symmetry breaking into two equal amplitude states)\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.plot_1D_solutions_branch","page":"API","title":"HarmonicSteadyState.plot_1D_solutions_branch","text":"plot_1D_solutions_branch(\n    starting_branch::Int64,\n    res::HarmonicSteadyState.Result;\n    x,\n    y,\n    sweep,\n    tf,\n    ϵ,\n    class,\n    not_class,\n    kwargs...\n)\n\n\nPlot a bifurcation diagram from a continuation sweep starting from starting_branch using the Result struct res. Time integration is used to determine what follow up branch in the continuation is.\n\nKeyword arguments\n\nx::String: Expression for the x-axis variable\ny::String: Expression for the y-axis variable\nsweep::String=\"right\": Direction to follow the branch (\"right\" or \"left\")\ntf::Real=10000: Final time for time integration\nϵ::Real=1e-4: Tolerance for branch following\nkwargs...: Additional plotting arguments passed to Plots.jl\nClass selection done by passing String or Vector{String} as kwarg:\nclass::String       :   only count solutions in this class (\"all\" –> plot everything)   not_class::String   :   do not count solutions in this class\n\nReturns\n\nA Plots.jl plot object containing the bifurcation diagram with the followed branch\n\nDescription\n\nThis function creates a bifurcation diagram using follow_branch. The followed branch is plotted as a dashed gray line.\n\n\n\n\n\n","category":"function"},{"location":"API/#HarmonicSteadyState.follow_branch-Tuple{Int64, HarmonicSteadyState.Result}-API","page":"API","title":"HarmonicSteadyState.follow_branch","text":"follow_branch(\n    starting_branch::Int64,\n    res::HarmonicSteadyState.Result;\n    y,\n    sweep,\n    tf,\n    ϵ\n) -> Tuple{Any, Any}\n\n\nReturn the indexes and values following stable branches along a 1D sweep. When a no stable solutions are found (e.g. in a bifurcation), the next stable solution is calculated by time evolving the previous solution (quench).\n\nKeyword arguments\n\ny:  Dependent variable expression (parsed into Symbolics.jl) to evaluate the followed solution branches on .\nsweep: Direction for the sweeping of solutions. A right (left) sweep proceeds from the first (last) solution, ordered as the sweeping parameter.\ntf: time to reach steady\nϵ: small random perturbation applied to quenched solution, in a bifurcation in order to favour convergence in cases where multiple solutions are identically accessible (e.g. symmetry breaking into two equal amplitude states)\n\n\n\n\n\n","category":"method"},{"location":"API/#SteadyStateSweep","page":"API","title":"SteadyStateSweep","text":"","category":"section"},{"location":"API/#HarmonicSteadyState.steady_state_sweep","page":"API","title":"HarmonicSteadyState.steady_state_sweep","text":"steady_state_sweep(prob::SteadyStateProblem, alg::DynamicSS; varied::Pair, kwargs...)\n\nSweeps through a range of parameter values using a dynamic steady state solver DynamicSS of the SteadyStateDiffEq.jl package. Given a steady state problem and a parameter to vary, computes the steady state solution for each value in the sweep range. The solutions are returned as a vector where each element corresponds to the steady state found at that parameter value.\n\n\n\n\n\nsteady_state_sweep(prob_np::NonlinearProblem, prob_ss::SteadyStateProblem,\n                  alg_np, alg_ss::DynamicSS; varied::Pair, kwargs...)\n\nPerforms a parameter sweep by combining nonlinear root alg_np and steady state solvers alg_ss. For each parameter value, it first attempts a direct nonlinear root solver and checks its stability. If the solution is unstable or not found, it switches to a dynamic steady state solver. This hybrid approach is much faster then only using a steady state solver.\n\n\n\n\n\n","category":"function"}]
}
