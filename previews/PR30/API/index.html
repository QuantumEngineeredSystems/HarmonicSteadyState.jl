<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · HarmonicSteadyState.jl</title><meta name="title" content="API · HarmonicSteadyState.jl"/><meta property="og:title" content="API · HarmonicSteadyState.jl"/><meta property="twitter:title" content="API · HarmonicSteadyState.jl"/><meta name="description" content="Documentation for HarmonicSteadyState.jl."/><meta property="og:description" content="Documentation for HarmonicSteadyState.jl."/><meta property="twitter:description" content="Documentation for HarmonicSteadyState.jl."/><meta property="og:url" content="https://quantumengineeredsystems.github.io/HarmonicSteadyState.jl/stable/API/"/><meta property="twitter:url" content="https://quantumengineeredsystems.github.io/HarmonicSteadyState.jl/stable/API/"/><link rel="canonical" href="https://quantumengineeredsystems.github.io/HarmonicSteadyState.jl/stable/API/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HarmonicSteadyState.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Finding-steady-states"><span>Finding steady states</span></a></li><li><a class="tocitem" href="#Analyze-solutions"><span>Analyze solutions</span></a></li><li><a class="tocitem" href="#Linear-response"><span>Linear response</span></a></li><li><a class="tocitem" href="#Limit-cycle-methods"><span>Limit-cycle methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/main/docs/src/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#Finding-steady-states">Finding steady states</a></li><li class="no-marker"><ul><li><a href="#Homotopy-Continuation">Homotopy Continuation</a></li></ul></li><li><a href="#Analyze-solutions">Analyze solutions</a></li><li class="no-marker"><ul><li><a href="#Access-steady-states">Access steady states</a></li><li><a href="#Classify-steady-states">Classify steady states</a></li><li><a href="#Steady-state-plotting">Steady state plotting</a></li></ul></li><li><a href="#Linear-response">Linear response</a></li><li class="no-marker"><ul><li><a href="#Linear-response-plotting">Linear response plotting</a></li></ul></li><li><a href="#Limit-cycle-methods">Limit-cycle methods</a></li><li class="no-marker"><ul><li><a href="#OrdinaryDiffEq">OrdinaryDiffEq</a></li><li><a href="#SteadyStateSweep">SteadyStateSweep</a></li></ul></li></ul><h2 id="Finding-steady-states"><a class="docs-heading-anchor" href="#Finding-steady-states">Finding steady states</a><a id="Finding-steady-states-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-steady-states" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.get_steady_states" href="#HarmonicSteadyState.get_steady_states"><code>HarmonicSteadyState.get_steady_states</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_steady_states(
    prob::HomotopyContinuationProblem,
    method::HomotopyContinuationMethod;
    show_progress=true,
    sorting=&quot;nearest&quot;,
    classify_default=true,
    verbose=false
    )</code></pre><p>Solves <code>problem</code> with the <code>method</code> over the ranges specified by <code>swept_parameters</code>, keeping <code>fixed_parameters</code> constant. <code>swept_parameters</code> accepts pairs mapping symbolic variables to arrays or ranges. <code>fixed_parameters</code> accepts pairs mapping symbolic variables to numbers.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress</code>: Indicate whether a progress bar should be displayed.</li><li><code>sorting</code>: the method used by <code>sort_solutions</code> to get continuous solutions branches.   The current options are <code>&quot;hilbert&quot;</code> (1D sorting along a Hilbert curve), <code>&quot;nearest&quot;</code>   (nearest-neighbor sorting) and <code>&quot;none&quot;</code>.</li><li><code>classify_default</code>: If <code>true</code>, the solutions will be classified using the default   classification method.</li></ul><p><strong>Example</strong></p><p>solving a simple harmonic oscillator <span>$m \ddot{x} + γ \dot{x} + ω_0^2 x = F \cos(ωt)$</span> to obtain the response as a function of <span>$ω$</span></p><pre><code class="language-julia-repl hljs"># having obtained a HomotopyContinuationProblem object, let&#39;s find steady states
julia&gt; range = (ω =&gt; range(0.8, 1.2, 100) ) # 100 parameter sets to solve
julia&gt; fixed = ParameterList(m =&gt; 1, γ =&gt; 0.01, F =&gt; 0.5, ω_0 =&gt; 1)
julia&gt; get_steady_states(problem, range, fixed)

A steady state result for 100 parameter points

    Solution branches:   1
       of which real:    1
       of which stable:  1

    Classes: stable, physical, Hopf, binary_labels
</code></pre><p>It is also possible to perform 2-dimensional sweeps.</p><pre><code class="language-julia-repl hljs"># The swept parameters take precedence over fixed -&gt; use the same fixed
julia&gt; range = (ω =&gt; range(0.8,1.2,100), F =&gt; range(0.1,1.0,10) )

# The swept parameters take precedence over fixed -&gt; the F in fixed is now ignored
julia&gt; get_steady_states(problem, range, fixed)

A steady state result for 1000 parameter points

    Solution branches:   1
       of which real:    1
       of which stable:  1

    Classes: stable, physical, Hopf, binary_labels</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/solve_homotopy.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.SteadyStateProblem" href="#HarmonicSteadyState.SteadyStateProblem"><code>HarmonicSteadyState.SteadyStateProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SteadyStateProblem

Abstract type for steady state problems.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/Problem.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.SteadyStateMethod" href="#HarmonicSteadyState.SteadyStateMethod"><code>HarmonicSteadyState.SteadyStateMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SteadyStateMethod</code></pre><p>Abstract type for steady state methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/methods.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.Result" href="#HarmonicSteadyState.Result"><code>HarmonicSteadyState.Result</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Result{D, SolType&lt;:Number, ParType&lt;:Number, F&lt;:FunctionWrappers.FunctionWrapper{Array{SolType&lt;:Number, 2}, Tuple{Array{SolType&lt;:Number, 1}}}}</code></pre><p>Stores the steady states of a HarmonicEquation.</p><p><strong>Fields</strong></p><ul><li><p><code>solutions::Array{Array{Vector{SolType}, 1}, D} where {D, SolType&lt;:Number}</code>: The variable values of steady-state solutions.</p></li><li><p><code>swept_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Vector{ParType}} where ParType&lt;:Number</code>: Values of all parameters for all solutions.</p></li><li><p><code>fixed_parameters::OrderedCollections.OrderedDict{Symbolics.Num, ParType} where ParType&lt;:Number</code>: The parameters fixed throughout the solutions.</p></li><li><p><code>problem::HarmonicSteadyState.HomotopyContinuationProblem{ParType, F} where {SolType&lt;:Number, ParType&lt;:Number, F&lt;:FunctionWrappers.FunctionWrapper{Matrix{SolType}, Tuple{Vector{SolType}}}}</code>: The <code>HomotopyContinuationProblem</code> used to generate this.</p></li><li><p><code>classes::Dict{String, Array{BitVector, D}} where D</code>: Maps strings such as &quot;stable&quot;, &quot;physical&quot; etc to arrays of values, classifying the solutions (see method <code>classify_solutions!</code>).</p></li></ul><ul><li><code>binary_labels::Array{Int64}</code>: Create binary classification of the solutions, such that each solution point receives an identifier based on its permutation of stable branches (allows to distinguish between different phases, which may have the same number of stable solutions). It works by converting each bitstring <code>[is_stable(solution_1), is_stable(solution_2), ...,]</code> into unique labels.</li></ul><ul><li><code>jacobian::FunctionWrappers.FunctionWrapper{Matrix{SolType}, Tuple{Vector{SolType}}} where SolType&lt;:Number</code>: The Jacobian function with <code>fixed_parameters</code> already substituted. Accepts a vector specifying the solution. If problem.jacobian is a symbolic matrix, this holds a compiled function.</li></ul><ul><li><code>seed::UInt32</code>: Seed used for the solver</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/Result.jl#L1">source</a></section></article><h3 id="Homotopy-Continuation"><a class="docs-heading-anchor" href="#Homotopy-Continuation">Homotopy Continuation</a><a id="Homotopy-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Homotopy-Continuation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.HomotopyContinuationProblem" href="#HarmonicSteadyState.HomotopyContinuationProblem"><code>HarmonicSteadyState.HomotopyContinuationProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct HomotopyContinuationProblem{ParType&lt;:Number, Jac&lt;:FunctionWrappers.FunctionWrapper{Matrix{ComplexF64}, Tuple{Vector{ComplexF64}}}} &lt;: HarmonicSteadyState.SteadyStateProblem</code></pre><p>Holds a set of algebraic equations describing the steady state of a system.</p><p><strong>Fields</strong></p><ul><li><p><code>variables::Vector{Symbolics.Num}</code>: The harmonic variables to be solved for.</p></li><li><p><code>parameters::Vector{Symbolics.Num}</code>: All symbols which are not the harmonic variables.</p></li><li><p><code>swept_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Vector{ParType}} where ParType&lt;:Number</code>: The swept parameters in the homotopy.</p></li><li><p><code>fixed_parameters::OrderedCollections.OrderedDict{Symbolics.Num, ParType} where ParType&lt;:Number</code>: The fixed parameters in the homotopy.</p></li><li><p><code>system::HomotopyContinuation.ModelKit.System</code>: The input object for HomotopyContinuation.jl solver methods.</p></li><li><p><code>jacobian::FunctionWrappers.FunctionWrapper{Matrix{ComplexF64}, Tuple{Vector{ComplexF64}}}</code>: The Jacobian matrix (possibly symbolic or compiled function). If <code>Matrix{Nan}</code> and implicit function is compiled when a <code>Result</code> is created.</p></li></ul><ul><li><code>eom::QuestBase.HarmonicEquation</code>: The HarmonicEquation object used to generate this <code>HomotopyContinuationProblem</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HomotopyContinuationProblem(
    eom::HarmonicEquation,
    swept::AbstractDict,
    fixed::AbstractDict;
    compile_Jacobian::Bool=true,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/Problem.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.HomotopyContinuationMethod" href="#HarmonicSteadyState.HomotopyContinuationMethod"><code>HarmonicSteadyState.HomotopyContinuationMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HomotopyContinuationMethod</code></pre><p>Abstract type for the steady state methods using HomotopyContinuation.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/methods.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.WarmUp" href="#HarmonicSteadyState.WarmUp"><code>HarmonicSteadyState.WarmUp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WarmUp</code></pre><p>The Warm Up method prepares a warmup system with the Total Degree method using the parameter at <code>index</code> perturbed by <code>perturbation_size</code>. The warmup system is used to perform a homotopy using all other systems in the parameter sweep. It is very efficient for systems with minimal bifurcation in the parameter sweep. The Warm Up method should in theory guarantee to find all solutions, however, if the <code>start_parameters</code> is not proper (to close to the real line) it could miss some solutions.</p><p>See<a href="https://www.juliahomotopycontinuation.org/guides/many-systems/">HomotopyContinuation.jl</a> for more information.</p><p><strong>Fields</strong></p><ul><li><p><code>warm_up_method::Union{Polyhedral{T}, TotalDegree{T}} where T</code>: Method used for the warmup system.</p></li><li><p><code>start_parameters::Vector</code>: Start parameters.</p></li><li><p><code>thread::Bool</code>: Boolean indicating if threading is enabled.</p></li><li><p><code>check_zero::Bool</code>: Check if zero is a root</p></li><li><p><code>tracker_options::HomotopyContinuation.TrackerOptions</code>: Options for the tracker.</p></li><li><p><code>endgame_options::HomotopyContinuation.EndgameOptions</code>: Options for the endgame.</p></li><li><p><code>compile::Union{Bool, Symbol}</code>: Compilation options.</p></li><li><p><code>seed::UInt32</code>: Seed for random number generation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/methods.jl#L117-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.TotalDegree" href="#HarmonicSteadyState.TotalDegree"><code>HarmonicSteadyState.TotalDegree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TotalDegree</code></pre><p>The Total Degree homotopy method performs a homotopy <span>$H(x, t) = γ t G(x) + (1-t) F(x)$</span> from the trivial polynomial system <span>$F(x) =xᵢ^{dᵢ} +aᵢ$</span> with the maximal degree <span>$dᵢ$</span> determined by the <a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem">Bezout bound</a>. The method guarantees to find all solutions, however, it comes with a high computational cost. See <a href="https://www.juliahomotopycontinuation.org/guides/totaldegree/">HomotopyContinuation.jl</a> for more information.</p><p><strong>Fields</strong></p><ul><li><p><code>gamma::Complex</code>: Complex multiplying factor of the start system G(x) for the homotopy</p></li><li><p><code>thread::Bool</code>: Boolean indicating if threading is enabled.</p></li><li><p><code>tracker_options::HomotopyContinuation.TrackerOptions</code>: Options for the tracker.</p></li><li><p><code>endgame_options::HomotopyContinuation.EndgameOptions</code>: Options for the endgame.</p></li><li><p><code>compile::Union{Bool, Symbol}</code>: Compilation options.</p></li><li><p><code>seed::UInt32</code>: Seed for random number generation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/methods.jl#L15-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.Polyhedral" href="#HarmonicSteadyState.Polyhedral"><code>HarmonicSteadyState.Polyhedral</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Polyhedral</code></pre><p>The Polyhedral homotopy method constructs a homotopy based on the polyhedral structure of the polynomial system. It is more efficient than the Total Degree method for sparse systems, meaning most of the coefficients are zero. It can be especially useful if you don&#39;t need to find the zero solutions (<code>only_non_zero = true</code>), resulting in a speed up. See <a href="https://www.juliahomotopycontinuation.org/guides/polyhedral/">HomotopyContinuation.jl</a> for more information.</p><p><strong>Fields</strong></p><ul><li><p><code>only_non_zero::Bool</code>: Boolean indicating if only non-zero solutions are considered.</p></li><li><p><code>thread::Bool</code>: Boolean indicating if threading is enabled.</p></li><li><p><code>tracker_options::HomotopyContinuation.TrackerOptions</code>: Options for the tracker.</p></li><li><p><code>endgame_options::HomotopyContinuation.EndgameOptions</code>: Options for the endgame.</p></li><li><p><code>compile::Union{Bool, Symbol}</code>: Compilation options.</p></li><li><p><code>seed::UInt32</code>: Seed for random number generation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/methods.jl#L64-L76">source</a></section></article><h2 id="Analyze-solutions"><a class="docs-heading-anchor" href="#Analyze-solutions">Analyze solutions</a><a id="Analyze-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Analyze-solutions" title="Permalink"></a></h2><h3 id="Access-steady-states"><a class="docs-heading-anchor" href="#Access-steady-states">Access steady states</a><a id="Access-steady-states-1"></a><a class="docs-heading-anchor-permalink" href="#Access-steady-states" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.get_solutions" href="#HarmonicSteadyState.get_solutions"><code>HarmonicSteadyState.get_solutions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_solutions(
    res::Result, x::String;
    branches=1:branch_count(res), realify=false, class=[&quot;stable&quot;], not_class=[]
    )
get_solutions(res::Result; branches=1:branch_count(res), class=[&quot;stable&quot;], not_class=[])</code></pre><p>Extract solution vectors from a <code>Result</code> object based on specified filtering criteria given by the <code>class</code> keywords. The first method allows extracting a specific solution component by name <code>x</code>. The second method returns complete solution vectors.</p><p><strong>Keyword arguments</strong></p><ul><li><code>branches=1:branch_count(res)</code>: Range of branches to include in the output</li><li><code>realify=false</code>: Whether to convert complex solutions to real form</li><li><code>class=[&quot;physical&quot;, &quot;stable&quot;]</code>: Array of classification labels to include</li><li><code>not_class=[]</code>: Array of classification labels to exclude</li></ul><p><strong>Returns</strong></p><p>Filtered solution vectors matching the specified criteria</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/transform_solutions.jl#L196-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.get_single_solution" href="#HarmonicSteadyState.get_single_solution"><code>HarmonicSteadyState.get_single_solution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_single_solution(
    res::HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}};
    branch,
    index
)
</code></pre><p>Return an ordered dictionary specifying all variables and parameters of the solution in <code>result</code> on <code>branch</code> at the position <code>index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/transform_solutions.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.attractors" href="#HarmonicSteadyState.attractors"><code>HarmonicSteadyState.attractors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">attractors(res::Result{D}; class=&quot;stable&quot;, not_class=[]) where D</code></pre><p>Extract attractors from a <a href="#HarmonicSteadyState.Result"><code>Result</code></a> object. Returns an array of dictionaries, where each dictionary maps branch identifier to the attractor. The attractors are filtered by their corresponding class.</p><p><strong>Keyword arguments</strong></p><p>Class selection done by passing <code>String</code> or <code>Vector{String}</code> as kwarg:</p><pre><code class="nohighlight hljs">class::String       :   only count solutions in this class (&quot;all&quot; --&gt; plot everything)
not_class::String   :   do not count solutions in this class</code></pre><p><strong>Returns</strong></p><p><code>Array{Dict,D}</code>: Vector of dictionaries mapping branch indices to points satisfying   the stability criteria at each parameter value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/Result.jl#L122-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.transform_solutions" href="#HarmonicSteadyState.transform_solutions"><code>HarmonicSteadyState.transform_solutions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform_solutions(
    res::HarmonicSteadyState.Result{D, S, ParType, F} where {ParType&lt;:Number, F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}}},
    func;
    branches,
    realify
) -&gt; Vector
</code></pre><p>Takes a <code>Result</code> object and a string <code>f</code> representing a Symbolics.jl expression. Returns an array with the values of <code>f</code> evaluated for the respective solutions. Additional substitution rules can be specified in <code>rules</code> in the format <code>(&quot;a&quot; =&gt; val)</code> or <code>(a =&gt; val)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/transform_solutions.jl#L66">source</a></section></article><h3 id="Classify-steady-states"><a class="docs-heading-anchor" href="#Classify-steady-states">Classify steady states</a><a id="Classify-steady-states-1"></a><a class="docs-heading-anchor-permalink" href="#Classify-steady-states" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.classify_solutions!" href="#HarmonicSteadyState.classify_solutions!"><code>HarmonicSteadyState.classify_solutions!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_solutions!(
    res::HarmonicSteadyState.Result,
    func::Union{Function, String},
    name::String;
    physical
) -&gt; Any
</code></pre><p>Creates a solution class in <code>res</code> using the function <code>func</code> (parsed into Symbolics.jl input). The new class is labeled with <code>name</code> and stored under <code>res.classes[name]</code>. By default, only physical (real) solutions are classified, and <code>false</code> is returned for the rest. To also classify complex solutions, set <code>physical=false</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># solve a previously-defined problem
res = get_steady_states(problem, swept_parameters, fixed_parameters)

# classify, store in result.classes[&quot;large_amplitude&quot;]
classify_solutions!(res, &quot;sqrt(u1^2 + v1^2) &gt; 1.0&quot; , &quot;large_amplitude&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/classification.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.get_class" href="#HarmonicSteadyState.get_class"><code>HarmonicSteadyState.get_class</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_class(
    res::HarmonicSteadyState.Result,
    branch::Int64,
    class::String
) -&gt; Any
</code></pre><p>Returns an array of booleans classifying <code>branch</code> in the solutions in <code>res</code> according to <code>class</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/classification.jl#L43">source</a></section><section><div><pre><code class="language-julia hljs">get_class(
    soln::HarmonicSteadyState.Result,
    class::String
) -&gt; Vector
</code></pre><p>Returns an array of booleans classifying each branch in the solutions in <code>res</code> according to <code>class</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/classification.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.filter_result!" href="#HarmonicSteadyState.filter_result!"><code>HarmonicSteadyState.filter_result!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_result!(
    res::HarmonicSteadyState.Result,
    class::String
)
</code></pre><p>Removes all solution branches from <code>res</code> where NONE of the solution falls into <code>class</code>. Typically used to filter out unphysical solutions to prevent huge file sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/classification.jl#L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.phase_diagram" href="#HarmonicSteadyState.phase_diagram"><code>HarmonicSteadyState.phase_diagram</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_diagram(res::Result{D}; class=&quot;physical&quot;, not_class=[]) where {D}</code></pre><p>Calculate the phase diagram from a <code>Result</code> object by summing over the number of states at each swept parameters.</p><p><strong>Keyword arguments</strong></p><p>Class selection done by passing <code>String</code> or <code>Vector{String}</code> as kwarg:</p><pre><code class="nohighlight hljs">class::String       :   only count solutions in this class (&quot;all&quot; --&gt; plot everything)
not_class::String   :   do not count solutions in this class</code></pre><p><strong>Returns</strong></p><ul><li>Array{Int64,D}: Sum of states after applying the specified class masks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/Result.jl#L92-L106">source</a></section></article><h3 id="Steady-state-plotting"><a class="docs-heading-anchor" href="#Steady-state-plotting">Steady state plotting</a><a id="Steady-state-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-plotting" title="Permalink"></a></h3><p>To use these plotting functions, you need to have the <code>Plots</code> package installed in the same enverionment and loaded.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.plot-Tuple{HarmonicSteadyState.Result, Vararg{Any}}" href="#RecipesBase.plot-Tuple{HarmonicSteadyState.Result, Vararg{Any}}"><code>RecipesBase.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(
    res::HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},
    varargs...;
    cut,
    kwargs...
) -&gt; Plots.Plot
</code></pre><p><strong>Plot a <code>Result</code> object.</strong></p><p>Class selection done by passing <code>String</code> or <code>Vector{String}</code> as kwarg:</p><pre><code class="nohighlight hljs">class       :   only plot solutions in this class(es) (&quot;all&quot; --&gt; plot everything)
not_class   :   do not plot solutions in this class(es)</code></pre><p>Other kwargs are passed onto Plots.gr().</p><p>See also <code>plot!</code></p><p>The x,y,z arguments are Strings compatible with Symbolics.jl, e.g., <code>y=2*sqrt(u1^2+v1^2)</code> plots the amplitude of the first quadratures multiplied by 2.</p><p><strong>1D plots</strong></p><pre><code class="nohighlight hljs">plot(res::Result; x::String, y::String, class=&quot;default&quot;, not_class=[], kwargs...)
plot(res::Result, y::String; kwargs...) # take x automatically from Result</code></pre><p>Default behaviour is to plot stable solutions as full lines, unstable as dashed.</p><p>If a sweep in two parameters were done, i.e., <code>dimension(res)==2</code>, a one dimensional cut can be plotted by using the keyword <code>cut</code> were it takes a <code>Pair{Num, Float}</code> type entry. For example, <code>plot(res, y=&quot;sqrt(u1^2+v1^2), cut=(λ =&gt; 0.2))</code> plots a cut at <code>λ = 0.2</code>.</p><p><strong>2D plots</strong></p><pre><code class="nohighlight hljs">plot(res::Result; z::String, branch::Int64, class=&quot;physical&quot;, not_class=[], kwargs...)</code></pre><p>To make the 2d plot less chaotic it is required to specify the specific <code>branch</code> to plot, labeled by a <code>Int64</code>.</p><p>The x and y axes are taken automatically from <code>res</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/steady_states.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.plot!-Tuple{HarmonicSteadyState.Result, Vararg{Any}}" href="#RecipesBase.plot!-Tuple{HarmonicSteadyState.Result, Vararg{Any}}"><code>RecipesBase.plot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot!(
    res::HarmonicSteadyState.Result,
    varargs...;
    kwargs...
) -&gt; Plots.Plot
</code></pre><p>Similar to <code>plot</code> but adds a plot onto an existing plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/steady_states.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.plot_phase_diagram" href="#HarmonicSteadyState.plot_phase_diagram"><code>HarmonicSteadyState.plot_phase_diagram</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_phase_diagram(
    res::HarmonicSteadyState.Result{D, SolType} where SolType&lt;:Number;
    kwargs...
) -&gt; Plots.Plot
</code></pre><p>Plot the number of solutions in a <code>Result</code> object as a function of the parameters. Works with 1D and 2D datasets.</p><p>Class selection done by passing <code>String</code> or <code>Vector{String}</code> as kwarg:</p><pre><code class="nohighlight hljs">class::String       :   only count solutions in this class (&quot;all&quot; --&gt; plot everything)
not_class::String   :   do not count solutions in this class</code></pre><p>Other kwargs are passed onto Plots.gr()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/steady_states.jl#L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.plot_spaghetti" href="#HarmonicSteadyState.plot_spaghetti"><code>HarmonicSteadyState.plot_spaghetti</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_spaghetti(
    res::HarmonicSteadyState.Result{D, SolType} where SolType&lt;:Number;
    x,
    y,
    z,
    class,
    not_class,
    add,
    kwargs...
)
</code></pre><p>Plot a three dimension line plot of a <code>Result</code> object as a function of the parameters. Works with 1D and 2D datasets.</p><p>Class selection done by passing <code>String</code> or <code>Vector{String}</code> as kwarg:</p><pre><code class="nohighlight hljs">class::String       :   only count solutions in this class (&quot;all&quot; --&gt; plot everything)
not_class::String   :   do not count solutions in this class</code></pre><p>Other kwargs are passed onto Plots.gr()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/steady_states.jl#L300">source</a></section></article><h2 id="Linear-response"><a class="docs-heading-anchor" href="#Linear-response">Linear response</a><a id="Linear-response-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-response" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LinearResponse.eigenvalues-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any}} where {D, S, P}" href="#HarmonicSteadyState.LinearResponse.eigenvalues-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any}} where {D, S, P}"><code>HarmonicSteadyState.LinearResponse.eigenvalues</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigenvalues(res::Result, branch; class=[&quot;physical&quot;])</code></pre><p>Calculate the eigenvalues of the Jacobian matrix of the harmonic equations of a <code>branch</code> for a one dimensional sweep in the <a href="#HarmonicSteadyState.Result">Result</a> struct.</p><p><strong>Arguments</strong></p><ul><li><code>res::Result</code>: Result object containing solutions and jacobian information</li><li><code>branch</code>: Index of the solution branch to analyze</li><li><code>class=[&quot;physical&quot;]</code>: Filter for solution classes to include, defaults to physical solutions</li></ul><p><strong>Returns</strong></p><ul><li>Vector of filtered eigenvalues along the solution branch</li></ul><p><strong>Notes</strong></p><ul><li>Currently only supports 1-dimensional parameter sweeps (D=1)</li><li>Will throw an error if branch contains NaN values</li><li>Eigenvalues are filtered based on the specified solution classes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LinearResponse/response.jl#L171-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LinearResponse.eigenvectors-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any}} where {D, S, P}" href="#HarmonicSteadyState.LinearResponse.eigenvectors-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any}} where {D, S, P}"><code>HarmonicSteadyState.LinearResponse.eigenvectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigenvectors(res::Result, branch; class=[&quot;physical&quot;])</code></pre><p>get_Jacobiannch to analyze</p><ul><li><code>class=[&quot;physical&quot;]</code>: Filter for solution classes to include, defaults to physical solutions</li></ul><p><strong>Returns</strong></p><ul><li>Vector of filtered eigenvectors along the solution branch</li></ul><p><strong>Notes</strong></p><ul><li>Currently only supports 1-dimensional parameter sweeps (D=1)</li><li>Will throw an error if branch contains NaN values</li><li>Eigenvectors are filtered based on the specified solution classes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LinearResponse/response.jl#L214-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LinearResponse.get_jacobian_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Symbolics.Num, Any, Int64}} where {D, S, P}" href="#HarmonicSteadyState.LinearResponse.get_jacobian_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Symbolics.Num, Any, Int64}} where {D, S, P}"><code>HarmonicSteadyState.LinearResponse.get_jacobian_response</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_jacobian_response(
    res::HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},
    nat_var::Symbolics.Num,
    Ω_range,
    branch::Int64;
    show_progress
) -&gt; Matrix
</code></pre><p>Calculate the Jacobian response spectrum for a given system. Computes the magnitude of the Jacobian response for stable solutions across specified frequency ranges.</p><p><strong>Arguments</strong></p><ul><li><code>res::Result</code>: Result object containing the system&#39;s solutions</li><li><code>nat_var::Num</code>: Natural variable to evaluate in the response</li><li><code>Ω_range</code>: Range of frequencies to evaluate</li><li><code>branch::Int</code> or <code>followed_branches::Vector{Int}</code>: Branch number(s) to analyze</li><li><code>show_progress=true</code>: Whether to show a progress bar</li><li><code>force=false</code>: Force recalculation of spectrum even if already exists</li></ul><p><strong>Returns</strong></p><ul><li>Array{P,2}: Complex response matrix where rows correspond to frequencies and columns to solutions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LinearResponse/response.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LinearResponse.get_linear_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Symbolics.Num, Any, Int64}} where {D, S, P}" href="#HarmonicSteadyState.LinearResponse.get_linear_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Symbolics.Num, Any, Int64}} where {D, S, P}"><code>HarmonicSteadyState.LinearResponse.get_linear_response</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_linear_response(
    res::HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},
    nat_var::Symbolics.Num,
    Ω_range,
    branch::Int64;
    show_progress
)
</code></pre><p>Calculate the linear response of the system for a given branch. Evaluates the linear response by solving the linear response ODE for each stable solution and input frequency in the given range.</p><p><strong>Arguments</strong></p><ul><li><code>res</code>: Result object containing the system&#39;s solutions</li><li><code>nat_var::Num</code>: Natural variable to evaluate in the response</li><li><code>Ω_range</code>: Range of frequencies to evaluate</li><li><code>branch::Int</code>: Branch number to analyze</li><li><code>show_progress=true</code>: Whether to show a progress bar</li></ul><p><strong>Returns</strong></p><ul><li>Array{P,2}: Response matrix where rows correspond to frequencies and columns to stable solutions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LinearResponse/response.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LinearResponse.get_rotframe_jacobian_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any, Int64}} where {D, S, P}" href="#HarmonicSteadyState.LinearResponse.get_rotframe_jacobian_response-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Matrix{S}, Tuple{Vector{S}}}, Any, Int64}} where {D, S, P}"><code>HarmonicSteadyState.LinearResponse.get_rotframe_jacobian_response</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_rotframe_jacobian_response(
    res::HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},
    Ω_range,
    branch::Int64;
    show_progress,
    damping_mod
)
</code></pre><p>Calculate the rotating frame Jacobian response for a given branch. Computes the rotating frame Jacobian response by evaluating eigenvalues of the numerical Jacobian and calculating the response magnitude for each frequency in the range.</p><p><strong>Arguments</strong></p><ul><li><code>res::Result</code>: Result object containing the system&#39;s solutions</li><li><code>Ω_range</code>: Range of frequencies to evaluate</li><li><code>branch::Int</code>: Branch number to analyze</li><li><code>show_progress=true</code>: Whether to show a progress bar</li><li><code>damping_mod</code>: Damping modification parameter</li></ul><p><strong>Returns</strong></p><ul><li>Array{P,2}: Response matrix in the rotating frame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LinearResponse/response.jl#L118">source</a></section></article><h3 id="Linear-response-plotting"><a class="docs-heading-anchor" href="#Linear-response-plotting">Linear response plotting</a><a id="Linear-response-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-response-plotting" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.plot_eigenvalues" href="#HarmonicSteadyState.plot_eigenvalues"><code>HarmonicSteadyState.plot_eigenvalues</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_eigenvalues(
    res::HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},
    branch::Int64;
    class,
    type,
    projection,
    cscheme,
    kwargs...
) -&gt; Any
</code></pre><p>Visualize the eigenvalues of the Jacobian in the rotating frame for <code>branch</code> identifier in the <a href="#HarmonicSteadyState.Result">Result</a> <code>res</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>class</code>: Array of solution classes to include (default: [&quot;physical&quot;])</li><li><code>type</code>: Which part of eigenvalues to plot (<code>:real</code> or <code>:imag</code>, default: <code>:imag</code>)</li><li><code>projection</code>: Function mapping eigenvectors to colors (default: v-&gt;1)</li><li><code>cscheme</code>: Color scheme for plotting (<code>:default</code> or custom scheme)</li><li><code>kwargs...</code>: Additional arguments passed to Plots.scatter</li></ul><p><strong>Returns</strong></p><p>A scatter plot of eigenvalues colored by the projection of their eigenvectors.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Plot imaginary parts of eigenvalues
plot_eigenvalues(result, branch=1)

# Plot real parts with custom coloring based on the norm of eigenvectors of the first harmonic
plot_eigenvalues(result, branch=1, type=:real, projection=v-&gt;sqrt(v[1]^2+v[2]^2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/linear_response.jl#L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.plot_linear_response" href="#HarmonicSteadyState.plot_linear_response"><code>HarmonicSteadyState.plot_linear_response</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_linear_response(
    res::HarmonicSteadyState.Result{D, SolType} where SolType&lt;:Number,
    nat_var::Symbolics.Num,
    branch::Int64;
    Ω_range,
    order,
    logscale,
    show_progress,
    kwargs...
)
</code></pre><p>Plot the linear response to white noise of the variable <code>nat_var</code> for <a href="#HarmonicSteadyState.Result">Result</a> <code>res</code> on <code>branch</code> identifier.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Ω_range</code>: Range of frequency of the noise probe</li><li><code>order</code>: Order of slow-time derivatives to keep (default: 1)</li><li><code>logscale</code>: Whether to plot response in log scale (default: false)</li><li><code>show_progress</code>: Show progress bar during computation (default: true)</li><li><code>kwargs...</code>: Additional arguments passed to Plots.heatmap</li></ul><p><strong>Returns</strong></p><p>A Plots.jl heatmap showing the linear response magnitude across parameter and frequency space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/linear_response.jl#L2">source</a></section><section><div><pre><code class="language-julia hljs">plot_linear_response(
    res::HarmonicSteadyState.Result,
    nat_var::Symbolics.Num,
    followed_branches::Vector{Int64};
    Ω_range,
    logscale,
    show_progress,
    switch_axis,
    force,
    kwargs...
)
</code></pre><p>Plot the linear response to white noise of the variable <code>nat_var</code> for <a href="#HarmonicSteadyState.Result">Result</a> <code>res</code> on the <code>followed_branches</code> identifiers with the size of <code>Ω_range</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Ω_range</code>: Range of frequency of the noise probe</li><li><code>order</code>: Order of slow-time derivatives to keep (default: 1)</li><li><code>logscale</code>: Whether to plot response in log scale (default: false)</li><li><code>show_progress</code>: Show progress bar during computation (default: true)</li><li><code>kwargs...</code>: Additional arguments passed to Plots.heatmap</li></ul><p><strong>Returns</strong></p><p>A Plots.jl heatmap showing the linear response magnitude across parameter and frequency space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/linear_response.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.plot_rotframe_jacobian_response" href="#HarmonicSteadyState.plot_rotframe_jacobian_response"><code>HarmonicSteadyState.plot_rotframe_jacobian_response</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_rotframe_jacobian_response(
    res::HarmonicSteadyState.Result{D, S, P, F} where F&lt;:FunctionWrappers.FunctionWrapper{Array{S, 2}, Tuple{Array{S, 1}}},
    branch::Int64;
    Ω_range,
    logscale,
    damping_mod,
    show_progress,
    kwargs...
)
</code></pre><p>Plot the linear response to white noise in the rotating frame defined the harmonic ansatz for <a href="#HarmonicSteadyState.Result">Result</a> <code>res</code> on <code>branch</code> identifier.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Ω_range</code>: Range of frequencies to analyze</li><li><code>logscale</code>: Whether to plot response in log scale (default: true)</li><li><code>damping_mod</code>: Multiplier for the real part of Jacobian eigenvalues (default: 1.0)</li><li><code>show_progress</code>: Show progress bar during computation (default: true)</li><li><code>kwargs...</code>: Additional arguments passed to Plots.heatmap</li></ul><p><strong>Returns</strong></p><p>A Plots.jl heatmap showing the response magnitude in the rotating frame.</p><p><strong>Notes</strong></p><ul><li>Setting <code>damping_mod</code> &lt; 1 can help distinguish between peaks with similar frequencies</li><li>Solutions not belonging to the <code>physical</code> class are ignored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/linear_response.jl#L104">source</a></section></article><h2 id="Limit-cycle-methods"><a class="docs-heading-anchor" href="#Limit-cycle-methods">Limit-cycle methods</a><a id="Limit-cycle-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Limit-cycle-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LimitCycles.get_limit_cycles" href="#HarmonicSteadyState.LimitCycles.get_limit_cycles"><code>HarmonicSteadyState.LimitCycles.get_limit_cycles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_limit_cycles(
    eom::HarmonicEquation, method::SteadyStateMethod, swept, fixed, ω_lc; kwargs...)</code></pre><p>Variant of <code>get_steady_states</code> for a limit cycle problem characterised by a Hopf frequency (usually called ω_lc)</p><p>Solutions with ω_lc = 0 are labelled unphysical since this contradicts the assumption of distinct harmonic variables corresponding to distinct harmonics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LimitCycles/gauge_fixing.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LimitCycles.add_pairs!" href="#HarmonicSteadyState.LimitCycles.add_pairs!"><code>HarmonicSteadyState.LimitCycles.add_pairs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_pairs!(eom::DifferentialEquation; ω_lc::Num, n=1)</code></pre><p>Add a limit cycle harmonic <code>ω_lc</code> to the system Equivalent to adding <code>n</code> pairs of harmonics ω +- ω_lc for each existing ω.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LimitCycles/gauge_fixing.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.LimitCycles.get_cycle_variables" href="#HarmonicSteadyState.LimitCycles.get_cycle_variables"><code>HarmonicSteadyState.LimitCycles.get_cycle_variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cycle_variables(
    eom::QuestBase.HarmonicEquation,
    ω_lc::Symbolics.Num
) -&gt; Vector{QuestBase.HarmonicVariable}
</code></pre><p>Return the harmonic variables which participate in the limit cycle labelled by <code>ω_lc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/LimitCycles/gauge_fixing.jl#L22">source</a></section></article><h3 id="OrdinaryDiffEq"><a class="docs-heading-anchor" href="#OrdinaryDiffEq">OrdinaryDiffEq</a><a id="OrdinaryDiffEq-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.AdiabaticSweep" href="#HarmonicSteadyState.AdiabaticSweep"><code>HarmonicSteadyState.AdiabaticSweep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Represents a sweep of one or more parameters of a <code>HarmonicEquation</code>. During a sweep, the selected parameters vary linearly over some timespan and are constant elsewhere.</p><p>Sweeps of different variables can be combined using <code>+</code>.</p><p><strong>Fields</strong></p><ul><li><code>functions::Dict{Symbolics.Num, Function}</code>: Maps each swept parameter to a function.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># create a sweep of parameter a from 0 to 1 over time 0 -&gt; 100
julia&gt; @variables a,b;
julia&gt; sweep = AdiabaticSweep(a =&gt; [0., 1.], (0, 100));
julia&gt; sweep[a](50)
0.5
julia&gt; sweep[a](200)
1.0

# do the same, varying two parameters simultaneously
julia&gt; sweep = AdiabaticSweep([a =&gt; [0.,1.], b =&gt; [0., 1.]], (0,100))</code></pre><p>Successive sweeps can be combined,</p><pre><code class="language-julia-repl hljs">sweep1 = AdiabaticSweep(ω =&gt; [0.95, 1.0], (0, 2e4))
sweep2 = AdiabaticSweep(λ =&gt; [0.05, 0.01], (2e4, 4e4))
sweep = sweep1 + sweep2</code></pre><p>multiple parameters can be swept simultaneously,</p><pre><code class="language-julia-repl hljs">sweep = AdiabaticSweep([ω =&gt; [0.95;1.0], λ =&gt; [5e-2;1e-2]], (0, 2e4))</code></pre><p>and custom sweep functions may be used.</p><pre><code class="language-julia-repl hljs">ωfunc(t) = cos(t)
sweep = AdiabaticSweep(ω =&gt; ωfunc)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/src/types.jl#L9-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.follow_branch" href="#HarmonicSteadyState.follow_branch"><code>HarmonicSteadyState.follow_branch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">follow_branch(
    starting_branch::Int64,
    res::HarmonicSteadyState.Result;
    y,
    sweep,
    tf,
    ϵ
) -&gt; Tuple{Any, Any}
</code></pre><p>Return the indexes and values following stable branches along a 1D sweep. When a no stable solutions are found (e.g. in a bifurcation), the next stable solution is calculated by time evolving the previous solution (quench).</p><p><strong>Keyword arguments</strong></p><ul><li><code>y</code>:  Dependent variable expression (parsed into Symbolics.jl) to evaluate the followed solution branches on .</li><li><code>sweep</code>: Direction for the sweeping of solutions. A <code>right</code> (<code>left</code>) sweep proceeds from the first (last) solution, ordered as the sweeping parameter.</li><li><code>tf</code>: time to reach steady</li><li><code>ϵ</code>: small random perturbation applied to quenched solution, in a bifurcation in order to favour convergence in cases where multiple solutions are identically accessible (e.g. symmetry breaking into two equal amplitude states)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/TimeEvolution/hysteresis_sweep.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.plot_1D_solutions_branch" href="#HarmonicSteadyState.plot_1D_solutions_branch"><code>HarmonicSteadyState.plot_1D_solutions_branch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_1D_solutions_branch(
    starting_branch::Int64,
    res::HarmonicSteadyState.Result;
    x,
    y,
    sweep,
    tf,
    ϵ,
    class,
    not_class,
    kwargs...
)
</code></pre><p>Plot a bifurcation diagram from a continuation sweep starting from <code>starting_branch</code> using the <a href="#HarmonicSteadyState.Result">Result</a> struct <code>res</code>. Time integration is used to determine what follow up branch in the continuation is.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>x::String</code>: Expression for the x-axis variable</p></li><li><p><code>y::String</code>: Expression for the y-axis variable</p></li><li><p><code>sweep::String=&quot;right&quot;</code>: Direction to follow the branch (&quot;right&quot; or &quot;left&quot;)</p></li><li><p><code>tf::Real=10000</code>: Final time for time integration</p></li><li><p><code>ϵ::Real=1e-4</code>: Tolerance for branch following</p></li><li><p><code>kwargs...</code>: Additional plotting arguments passed to Plots.jl</p></li><li><p>Class selection done by passing <code>String</code> or <code>Vector{String}</code> as kwarg:</p><p>class::String       :   only count solutions in this class (&quot;all&quot; –&gt; plot everything)   not_class::String   :   do not count solutions in this class</p></li></ul><p><strong>Returns</strong></p><ul><li>A Plots.jl plot object containing the bifurcation diagram with the followed branch</li></ul><p><strong>Description</strong></p><p>This function creates a bifurcation diagram using <a href="#HarmonicSteadyState.follow_branch"><code>follow_branch</code></a>. The followed branch is plotted as a dashed gray line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/PlotsExt/time_evolution.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.follow_branch-Tuple{Int64, HarmonicSteadyState.Result}-API" href="#HarmonicSteadyState.follow_branch-Tuple{Int64, HarmonicSteadyState.Result}-API"><code>HarmonicSteadyState.follow_branch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">follow_branch(
    starting_branch::Int64,
    res::HarmonicSteadyState.Result;
    y,
    sweep,
    tf,
    ϵ
) -&gt; Tuple{Any, Any}
</code></pre><p>Return the indexes and values following stable branches along a 1D sweep. When a no stable solutions are found (e.g. in a bifurcation), the next stable solution is calculated by time evolving the previous solution (quench).</p><p><strong>Keyword arguments</strong></p><ul><li><code>y</code>:  Dependent variable expression (parsed into Symbolics.jl) to evaluate the followed solution branches on .</li><li><code>sweep</code>: Direction for the sweeping of solutions. A <code>right</code> (<code>left</code>) sweep proceeds from the first (last) solution, ordered as the sweeping parameter.</li><li><code>tf</code>: time to reach steady</li><li><code>ϵ</code>: small random perturbation applied to quenched solution, in a bifurcation in order to favour convergence in cases where multiple solutions are identically accessible (e.g. symmetry breaking into two equal amplitude states)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/TimeEvolution/hysteresis_sweep.jl#L15">source</a></section></article><h3 id="SteadyStateSweep"><a class="docs-heading-anchor" href="#SteadyStateSweep">SteadyStateSweep</a><a id="SteadyStateSweep-1"></a><a class="docs-heading-anchor-permalink" href="#SteadyStateSweep" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HarmonicSteadyState.steady_state_sweep" href="#HarmonicSteadyState.steady_state_sweep"><code>HarmonicSteadyState.steady_state_sweep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">steady_state_sweep(prob::SteadyStateProblem, alg::DynamicSS; varied::Pair, kwargs...)</code></pre><p>Sweeps through a range of parameter values using a dynamic steady state solver <code>DynamicSS</code> of the <code>SteadyStateDiffEq.jl</code> package. Given a steady state problem and a parameter to vary, computes the steady state solution for each value in the sweep range. The solutions are returned as a vector where each element corresponds to the steady state found at that parameter value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/SteadyStateDiffEqExt.jl#L12-L20">source</a></section><section><div><pre><code class="language-julia hljs">steady_state_sweep(prob_np::NonlinearProblem, prob_ss::SteadyStateProblem,
                  alg_np, alg_ss::DynamicSS; varied::Pair, kwargs...)</code></pre><p>Performs a parameter sweep by combining nonlinear root <code>alg_np</code> and steady state solvers <code>alg_ss</code>. For each parameter value, it first attempts a direct nonlinear root solver and checks its stability. If the solution is unstable or not found, it switches to a dynamic steady state solver. This hybrid approach is much faster then only using a steady state solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumEngineeredSystems/HarmonicSteadyState.jl/blob/aa9029474d6d51b37f50632cca6a477d2432cabd/ext/SteadyStateDiffEqExt.jl#L39-L47">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Sunday 20 April 2025 09:59">Sunday 20 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
